module vedic_multiplier_4bit (
    input  logic [3:0] a,
    input  logic [3:0] b,
    output logic [7:0] y
);
    logic [3:0] q0, q1, q2, q3;
    logic [3:0] temp1, temp2, temp3;
    logic [4:0] temp_sum1, temp_sum2;

    // Partial products using 2-bit Vedic multipliers
    vedic_multiplier_2bit v0 (.a(a[1:0]), .b(b[1:0]), .y(q0));
    vedic_multiplier_2bit v1 (.a(a[3:2]), .b(b[1:0]), .y(q1));
    vedic_multiplier_2bit v2 (.a(a[1:0]), .b(b[3:2]), .y(q2));
    vedic_multiplier_2bit v3 (.a(a[3:2]), .b(b[3:2]), .y(q3));

    // Add cross products (aligned and zero-padded as needed)
    assign temp1 = {2'b00, q0[3:2]};   // Align q0[3:2] to bits [3:2]
    assign temp2 = q1;
    assign temp3 = q2;
    assign temp_sum1 = temp1 + temp2 + temp3; // Intermediate sum

    assign temp_sum2 = {q3, 2'b00} + {1'b0, temp_sum1[4:1]}; // Add higher products

    // Final product
    assign y[1:0] = q0[1:0];
    assign y[5:2] = temp_sum1[3:0];
    assign y[7:6] = temp_sum2[4:3];
endmodule

module vedic_multiplier_2bit (
    input  logic [1:0] a,
    input  logic [1:0] b,
    output logic [3:0] y
);
    assign y[0] = a[0] & b[0];

    logic s1, c1;
    assign s1 = (a[1] & b[0]) ^ (a[0] & b[1]);
    assign c1 = (a[1] & b[0]) & (a[0] & b[1]);
    assign y[1] = s1;
    assign y[2] = (a[1] & b[1]) ^ c1;
    assign y[3] = (a[1] & b[1]) & c1;
endmodule
